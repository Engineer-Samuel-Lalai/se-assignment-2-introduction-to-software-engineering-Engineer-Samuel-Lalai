[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-24ddc0f5d75046c5622901739e7c5dd533143b0c8e959d652212380cedb1ea36.svg)](https://classroom.github.com/a/-ucQIGTc)
[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-718a45dd9cf7e7f842a935f5ebbe5719a5e09af4491e668f4dbf3b35d5cca122.svg)](https://classroom.github.com/online_ide?assignment_repo_id=15213235&assignment_repo_type=AssignmentRepo)
# SE-Assignment-2 ANSWERS
# Assignment: Introduction to Software Engineering
# Instructions:
# Answer the following questions based on your understanding of software engineering concepts. Provide detailed explanations and examples where appropriate.

# Questions:

**Define Software Engineering:**

Software engineering is the systematic application of engineering principles, methods and tools to the development and maintenance of high quality software systems. It involves the design, development, testing, deployment and maintenance of software products. 

**What is software engineering, and how does it differ from traditional programming? Software Development Life Cycle (SDLC): Answer:**

Software engineering is an engineering discipline that is concerned with all aspects of
software production from the early stages of system specification through to maintaining the system after it has gone into use.

Differences between Software engineering and Traditional programming:
1. Traditional programming refers to the conventional approach of writing code to create specific instructions for a computer to follow. It involves explicitly defining every step and condition, leaving no room for the system to learn or adapt independently while software engineering is the systematic application of engineering principles, methods and tools to the development and maintenance of high quality software systems. It involves the design, development, testing, deployment and maintenance of software products.
2. Scope and Approach: Traditional programming often focuses on writing code to solve a specific problem or implement a particular feature. Software engineering, on the other hand, takes a broader approach, encompassing the entire software development lifecycle, including requirements analysis, design, coding, testing, deployment, and maintenance.
3. Methodologies: Software engineering often involves the use of formal methodologies such as Agile, Waterfall, or DevOps, which provide structured approaches to managing the software development process. Traditional programming may not adhere to such formal methodologies and may involve ad hoc coding practices.
4. Emphasis on Quality: Software engineering places a strong emphasis on quality assurance and testing throughout the development process. This includes unit testing, integration testing, system testing, and acceptance testing, among others. Traditional programming may focus less on formal testing procedures, leading to potentially lower software quality.
5. Documentation and Planning: Software engineering typically involves extensive documentation of requirements, design decisions, code comments, and user manuals. This documentation helps ensure that the software is well-understood and maintainable by other developers. Traditional programming may involve less emphasis on documentation and planning.
6. Team Collaboration: Software engineering often involves collaboration among team members, including developers, testers, designers, project managers, and stakeholders. Traditional programming may be more solitary, with individual programmers working independently on code.
7. Long-term Maintenance: Software engineering considers the long-term maintenance and evolution of software systems. This involves designing software in a modular and extensible way, as well as planning for future updates and enhancements. Traditional programming may focus more narrowly on solving immediate problems without considering long-term maintainability.

**What is Software Development Life Cycle (SDLC):**
Software Development Life Cycle (SDLC) is the cost-effective and time-efficient process that development teams use to design and build high-quality software. The goal of SDLC is to minimize project risks through forward planning so that software meets customer expectations during production and beyond.

**Explain the various phases of the Software Development Life Cycle. Provide a brief description of each phase. Agile vs. Waterfall Models:**
Software Development Life Cycle Phases include:
1. Requirements or Planning phase
The planning phase typically includes tasks like cost-benefit analysis, scheduling, resource estimation, and allocation. The development team collects requirements from several stakeholders such as customers, internal and external experts, and managers to create a software requirement specification document.
2. Design Phase
In the design phase, software engineers analyze requirements and identify the best solutions to create the software by creating high level and detailed designs of the software architecture and user interface. For example, they may consider integrating pre-existing modules, make technology choices, and identify development tools. They will look at how to best integrate the new software into any existing IT infrastructure the organization may have.
3. Implementation Phase
In the implementation phase, the development team codes the product. They analyze the requirements to identify smaller coding tasks they can do daily to achieve the final result.
4. Testing Phase 
The development team combines automation and manual testing to check the software for bugs. Quality analysis includes testing the software for errors and checking if it meets customer requirements. Because many teams immediately test the code they write, the testing phase often runs parallel to the development phase.
5. Deployment Phase 
When teams develop software, they code and test on a different copy of the software than the one that the users have access to. The software that customers use is called production, while other copies are said to be in the build environment, or testing environment. Having separate build and production environments ensures that customers can continue to use the software even while it is being changed or upgraded. The deployment phase includes several tasks to move the latest build copy to the production environment, such as packaging, environment configuration, and installation.
6. Maintainance
In the maintenance phase, among other tasks, the team fixes bugs, resolves customer issues, and manages software changes. In addition, the team monitors overall system performance, security, and user experience to identify new ways to improve the existing software.
The document sets expectations and defines common goals that aid in project planning. The team estimates costs, creates a schedule, and has a detailed plan to achieve their goals.

Compare and contrast the Agile and Waterfall models of software development. What are the key differences, and in what scenarios might each be preferred? Requirements Engineering:
1. Waterfall
The waterfall model arranges all the phases sequentially so that each new phase depends on the outcome of the previous phase. Conceptually, the design flows from one phase down to the next, like that of a waterfall.
Pros and cons
The waterfall model provides discipline to project management and gives a tangible output at the end of each phase. However, there is little room for change once a phase is considered complete, as changes can affect the software's delivery time, cost, and quality. Therefore, the model is most suitable for small software development projects, where tasks are easy to arrange and manage and requirements can be pre-defined accurately.
2. Agile
The agile model arranges the SDLC phases into several development cycles. The team iterates through the phases rapidly, delivering only small, incremental software changes in each cycle. They continuously evaluate requirements, plans, and results so that they can respond quickly to change. The agile model is both iterative and incremental, making it more efficient than other process models.
Pros and cons
Rapid development cycles help teams identify and address issues in complex projects early on and before they become significant problems. They can also engage customers and stakeholders to obtain feedback throughout the project lifecycle. However, overreliance on customer feedback could lead to excessive scope changes or end the project midway.

**What is requirements engineering? Describe the process and its importance in the software development lifecycle. Software Design Principles:**
Requirement engineering is the systematic use of proven principles, techniques, tools and languages for the cost effective analysis, documentation and ongoing evolution of user needs and the specification of the external behaviour of the system in order to satisfy these needs.

Requirement engineering process in software development is a process that involves all the activites required to create and mention a system requirement document.Requirement engineering provides the appropriate mechanism for understanding what the customer wants, analysing need, assessing feasibility, negotiating a reasonable solution, specifying the solution, validating the specification and managing the requirements as they are transformed into an operational system. Engineering procss involves the following activities;
i. Feasibility Study
ii. Requirements Elicitation
iii. Requirement Analysis
iv. Documentation or Requirement Specification
v. Review of user needs
vi. Management of user needs.

Importance of Requirement engineering in software development life cycle:
i. Helps ensure that the software being developed meets the needs and expectations of the stakeholders
ii. Can help identify potential issues or problems early in the development process, allowing for adjustments to be made before significant 
iii. Helps ensure that the software is developed in a cost-effective and efficient manner
iv. Can improve communication and collaboration between the development team and stakeholders
v. Helps to ensure that the software system meets the needs of all stakeholders.
vi. Provides an unambiguous description of the requirements, which helps to reduce misunderstandings and errors.
vii. Helps to identify potential conflicts and contradictions in the requirements, which can be resolved before the software development process begins.
viii. Helps to ensure that the software system is delivered on time, within budget, and to the required quality standards.
ix. Provides a solid foundation for the development process, which helps to reduce the risk of failure.
               
**Explain the concept of modularity in software design. How does it improve maintainability and scalability of software systems? Testing in Software Engineering:**
Modularity is probably the single most important characteristic of a well designed software system. A system is modular if it is composed of well defined conceptually simple and independent units interacting through well defined surfaces. 
Modularity improves maintanability by making the code more organized, reusable and maintainable. It allows parallel development and enhances collaboration among team members. If changes are needed, they can be made to individual modules without impacting the entire system.
Modularity improves scalability of software system by breaking down the software into independent modules, you can more easily adapt, extend, or replace parts of the system without affecting others.
Testing in Software Engineering: Testing is the verification and validation activity for software product Software Testing is a process of executing a program to locate an error. It involves checking processes such as inspection and reviews, at stage of the software process form user requirements definition to program development. Testing Process involves:
i. Unit testing
ii. Subsystem testing
iii.System testing
iv. Acceptance testing

**Describe the different levels of software testing (unit testing, integration testing, system testing, acceptance testing). Why is testing crucial in software development? Version Control Systems:**
Description of levels of testing process.
i. Unit testing: It ios the process of takng a program module and running it in isolation from the rest of the software product by using prepared inputs and comparing the actual results with the results predicted by the specifications and design of the module.Test cases are designed to test the following: 
    a, Internal logic of the module, 
    b, Functionality, 
    c, Interfaces, 
    d, Boundary conditions, 
    e, data structures and 
    f, All paths in the program module.
ii. Integration Testing: This focuses on testing the interfaces and interdependencies of subsystems or modules. The most common problem which arise in large software systems are interface mismatches. The subsystem test process should concentrate on the detection of module interface errors by rigorously exercising these interfaces.
There are a number of strategies that can be followed to do integration testing which include; Incremental strategy, Non-incremental strategyand mixed strategy.
iii. System testing: The system test tests all the subsystems to determine whether specific functionality is performed correctly as the results of the software. This process is also concerned with finding errors which result from unanticipated interactions between subsystems and subsystems inerface problems. A number of different types of testing are used at this stage; namely
        1. Functional testing
        2. Performance Testing
iv. Accepting Testing: System acceptance tests are performed against requirements. The system is tested with data supplied by the customer rather than the simulated test data. 

**What are version control systems, and why are they important in software development? Give examples of popular version control systems and their features. Software Project Management:**
Version control software keeps track of every modification to the code in a special kind of database. If a mistake is made, developers can turn back the clock and compare earlier versions of the code to help fix the mistake while minimizing disruption to all team members 
Benefits of version control Software:
i. Streamline merging and branching
ii. Examine and experiment with code
iii. Keep track of every change made to the code
iv. Create reqular, automated backups
v. Access every file's entire long term modification history.
vi. Communicate through open channels
vii. Discover the ability to operate offline
viii. Generate management summaries
ix. Stay compliant with reqularitions
x. Boost developer productivity
xi. Reduce error and duplication

Examples of popular Version Control Systems and their features include:
i. IBM Configuration Management Version Control (CMVC)
ii. Git
iii. Apache subversion
iv. Azure DevOps
v. Concurrent Version System (CVS)
vi. Mercurial
vii. Github
viii. AWS CodeCommit
ix. Bitbucket
x. RhodeCode
xi. Computer Associates Panvalet
xii. Helix Core
xiii. GNU Bazaar

Features of Version Control Software
i. Tracking changes
ii. Branching and merging
iii. Code review and collaboration
iv. Access controls and permissions
v. Integrations

**Discuss the role of a software project manager. What are some key responsibilities and challenges faced in managing software projects? Software Maintenance:**
Responsibilities and role of software project manager:
1. Planning everything from execution to delivery: this entails dividing the work into manageable chunks, using a hierachical breakdown of the tasks at hand, Establishing a reasonable timetable for the completion of specific outputs, Outlining key points, Bringing to light the interdependencies inside the project.
2. Oversee the Software Development Team by collaborating with the Business analysts, Web designers, Software developers, Content creators, Graphic designers, Sales and advertising teams and Marketing teams.
3. Delegating work effectively: Every project manager must practice and master this form of leadership, and doing so successfully is ultimately the manager’s job as a part of risk management.
4. Monitoring progress and tracking roadblocks: To monitor progress and ensure that work is proceeding as planned. During the project’s midsection, progress is accomplished via a variety of methods, including periodic reviews, briefings, and spontaneous updates.
5. Managing the Deployment deliverables: project managers oversee the preparation and carrying out of specific projects. They should be able to take charge, communicate well, and pay close attention  to detail.

Challenges faced in managing software projects include:
1. Unclear and undefined expectations
2. Time constraint
3. Changing project requirements and priorities
4. Poor communication
5. Skills management
6. Changing technologies
7. Keeping everyone on the same page
8. Motivating team members
9. Steep learning curve
10. Project cancellation
11. Estimation
12. High competition
13. Upgrade to a new system
14. Quality testing
15. Managing risks

**Define software maintenance and explain the different types of maintenance activities. Why is maintenance an essential part of the software lifecycle? Ethical Considerations in Software Engineering:**
Software maintenance is a set of activities undertaken on a software system following its release for operational use. Maintenance is the process in which changes are implemented by either modifying the existing system's architecture or by adding new components to the system. 
Types of software maintenance:
1. Corrective maintenance: Refers to modifications initiated by defects in the software. A defect can result from the following errors; Design errors, Logic errors and coding errors
2. Adaptive maintenance: This concerns external changes. Even if the software is error free, it is possible that the environment in which the software system works will often change. These changes can be as follows: Intoduction on new versions of operating systems, modifying the product to be interfaced with new hardware or software, moving the software to a different machine.
3. Perfective maintenance: This is for enhancement which involves processing efficiency or performance, or restructuring the software to improve changeability. Perfective maintenance requires the enhancement in the following cases; Enhancing existing system functionality, improving computational efficiency, improving user displays and modes of interaction, upgrading external and internal documentation and upgrading the performance characteristics of a system. 
4. Preventive maintenance: Means changes made to improve future maintainability.

Maintenance is an essential part of the software lifecycle due to the following reasons:
1. Correct problems: Errors undetected during software development may be found during use and require correction.
2. Enhance software products: Over a period of time, original requirements of the software may change to reflect the customer's needs.
3. Adaptation of products to new Environment: With the new technologies are introduced such as the new hardware, operating system etc. The software therefore must be modified to addopt to the new operating environment.

**What are some ethical issues that software engineers might face? How can software engineers ensure they adhere to ethical standards in their work?**

Ethical Considerations in Software Engineering: The software engineering code of ethics establishes guiding principles to help professionals make ethical decisions. These principles encompass 
1. Responsibility, 
2. Accountability, 
3. Fairness, and 
4. Justice.

The eight code of ethics for software proffesionals include:
1. PUBLIC
Software engineers shall act consistently with the public interest. In particular, software engineers shall, as appropriate:
i. Accept full responsibility for their own work.
ii. Moderate the interests of the software engineer, the employer, the client and the users with the public good.
iii. Approve software only if they have a well-founded belief that it is safe, meets specifications, passes appropriate tests, and does not diminish quality of life, diminish privacy or harm the environment. The ultimate effect of the work should be to the public good.
iv.Disclose to appropriate persons or authorities any actual or potential danger to the user, the public, or the environment, that they reasonably believe to be associated with software or related documents.
v.Cooperate in efforts to address matters of grave public concern caused by software, its installation, maintenance, support or documentation.
vi.Be fair and avoid deception in all statements, particularly public ones, concerning software or related documents, methods and tools.
vii.Consider issues of physical disabilities, allocation of resources, economic disadvantage and other factors that can diminish access to the benefits of software.
viii.Be encouraged to volunteer professional skills to good causes and contribute to public education concerning the discipline.

2. CLIENT AND EMPLOYER
Software engineers shall act in a manner that is in the best interests of their client and employer, consistent with the public interest. In particular, software engineers shall, as appropriate:
i. Provide service in their areas of competence, being honest and forthright about any limitations of their experience and education.
ii. Not knowingly use software that is obtained or retained either illegally or unethically.
iii. Use the property of a client or employer only in ways properly authorized, and with the client’s or employer’s knowledge and consent.
iv. Ensure that any document upon which they rely has been approved, when required, by someone authorized to approve it.
v. Keep private any confidential information gained in their professional work, where such confidentiality is consistent with the public interest and consistent with the law.
vi. Identify, document, collect evidence and report to the client or the employer promptly if, in their opinion, a project is likely to fail, to prove too expensive, to violate intellectual property law, or otherwise to be problematic.
vii. Identify, document, and report significant issues of social concern, of which they are aware, in software or related documents, to the employer or the client.
viii. Accept no outside work detrimental to the work they perform for their primary employer.
ix. Promote no interest adverse to their employer or client, unless a higher ethical concern is being compromised; in that case, inform the employer or another appropriate authority of the ethical concern.
3. PRODUCT
Software engineers shall ensure that their products and related modifications meet the highest professional standards possible. In particular, software engineers shall, as appropriate:
i. Strive for high quality, acceptable cost and a reasonable schedule, ensuring significant tradeoffs are clear to and accepted by the employer and the client, and are available for consideration by the user and the public.
ii. Ensure proper and achievable goals and objectives for any project on which they work or propose.
iii. Identify, define and address ethical, economic, cultural, legal and environmental issues related to work projects.
iv. Ensure that they are qualified for any project on which they work or propose to work by an appropriate combination of education and training, and experience.
v. Ensure an appropriate method is used for any project on which they work or propose to work.
vi. Work to follow professional standards, when available, that are most appropriate for the task at hand, departing from these only when ethically or technically justified.
vii. Strive to fully understand the specifications for software on which they work.
viii. Ensure that specifications for software on which they work have been well documented, satisfy the users requirements and have the appropriate approvals.
ix. Ensure realistic quantitative estimates of cost, scheduling, personnel, quality and outcomes on any project on which they work or propose to work and provide an uncertainty assessment of these estimates.
x. Ensure adequate testing, debugging, and review of software and related documents on which they work.
xi. Ensure adequate documentation, including significant problems discovered and solutions adopted, for any project on which they work.
xii. Work to develop software and related documents that respect the privacy of those who will be affected by that software.
xiii. Be careful to use only accurate data derived by ethical and lawful means, and use it only in ways properly authorized.
xiv. Maintain the integrity of data, being sensitive to outdated or flawed occurrences.
xv. Treat all forms of software maintenance with the same professionalism as new development.

4. JUDGMENT
Software engineers shall maintain integrity and independence in their professional judgment. In particular, software engineers shall, as appropriate:
i. Temper all technical judgments by the need to support and maintain human values.
ii Only endorse documents either prepared under their supervision or within their areas of competence and with which they are in agreement.
iii. Maintain professional objectivity with respect to any software or related documents they are asked to evaluate.
iv. Not engage in deceptive financial practices such as bribery, double billing, or other improper financial practices.
v. Disclose to all concerned parties those conflicts of interest that cannot reasonably be avoided or escaped.
vi. Refuse to participate, as members or advisors, in a private, governmental or professional body concerned with software related issues, in which they, their employers or their clients have undisclosed potential conflicts of interest.

5. MANAGEMENT
Software engineering managers and leaders shall subscribe to and promote an ethical approach to the management of software development and maintenance. In particular, those managing or leading software engineers shall, as appropriate:
i. Ensure good management for any project on which they work, including effective procedures for promotion of quality and reduction of risk.
ii. Ensure that software engineers are informed of standards before being held to them.
iii. Ensure that software engineers know the employer’s policies and procedures for protecting passwords, files and information that is confidential to the employer or confidential to others.
iv. Assign work only after taking into account appropriate contributions of education and experience tempered with a desire to further that education and experience.
v. Ensure realistic quantitative estimates of cost, scheduling, personnel, quality and outcomes on any project on which they work or propose to work, and provide an uncertainty assessment of these estimates.
vi. Attract potential software engineers only by full and accurate description of the conditions of employment.
vii. Offer fair and just remuneration.
viii. Not unjustly prevent someone from taking a position for which that person is suitably qualified.
ix. Ensure that there is a fair agreement concerning ownership of any software, processes, research, writing, or other intellectual property to which a software engineer has contributed.
x. Provide for due process in hearing charges of violation of an employer’s policy or of this Code.
xi. Not ask a software engineer to do anything inconsistent with this Code.
xii. Not punish anyone for expressing ethical concerns about a project.

6. PROFESSION
Software engineers shall advance the integrity and reputation of the profession consistent with the public interest. In particular, software engineers shall, as appropriate:
i. Help develop an organizational environment favorable to acting ethically.
ii. Promote public knowledge of software engineering.
iii. Extend software engineering knowledge by appropriate participation in professional organizations, meetings and publications.
iv. Support, as members of a profession, other software engineers striving to follow this Code.
v. Not promote their own interest at the expense of the profession, client or employer.
vi. Obey all laws governing their work, unless, in exceptional circumstances, such compliance is inconsistent with the public interest.
vii. Be accurate in stating the characteristics of software on which they work, avoiding not only false claims but also claims that might reasonably be supposed to be speculative, vacuous, deceptive, misleading, or doubtful.
viii. Take responsibility for detecting, correcting, and reporting errors in software and associated documents on which they work.
ix. Ensure that clients, employers, and supervisors know of the software engineer’s commitment to this Code of ethics, and the subsequent ramifications of such commitment.
x. Avoid associations with businesses and organizations which are in conflict with this code.
xi. Recognize that violations of this Code are inconsistent with being a professional software engineer.
xii. Express concerns to the people involved when significant violations of this Code are detected unless this is impossible, counter-productive, or dangerous.
xiii. Report significant violations of this Code to appropriate authorities when it is clear that consultation with people involved in these significant violations is impossible, counter-productive or dangerous.

7. COLLEAGUES
Software engineers shall be fair to and supportive of their colleagues. In particular, software engineers shall, as appropriate:
i. Encourage colleagues to adhere to this Code.
ii. Assist colleagues in professional development.
iii. Credit fully the work of others and refrain from taking undue credit.
iv. Review the work of others in an objective, candid, and properly- documented way.
v. Give a fair hearing to the opinions, concerns, or complaints of a colleague.
vi. Assist colleagues in being fully aware of current standard work practices including policies and procedures for protecting passwords, files and other confidential information, and security measures in general.
vii. Not unfairly intervene in the career of any colleague; however, concern for the employer, the client or public interest may compel software engineers, in good faith, to question the competence of a colleague.
viii. In situations outside of their own areas of competence, call upon the opinions of other professionals who have competence in that area.

8. SELF
Software engineers shall participate in lifelong learning regarding the practice of their profession and shall promote an ethical approach to the practice of the profession. In particular, software engineers shall continually endeavor to:
i. Further their knowledge of developments in the analysis, specification, design, development, maintenance and testing of software and related documents, together with the management of the development process.
ii. Improve their ability to create safe, reliable, and useful quality software at reasonable cost and within a reasonable time.
iii. Improve their ability to produce accurate, informative, and well-written documentation.
iv. Improve their understanding of the software and related documents on which they work and of the environment in which they will be used.
v. Improve their knowledge of relevant standards and the law governing the software and related documents on which they work.
vi. Improve their knowledge of this Code, its interpretation, and its application to their work.
vii. Not give unfair treatment to anyone because of any irrelevant prejudices.
viii. Not influence others to undertake any action that involves a breach of this Code.
ix. Recognize that personal violations of this Code are inconsistent with being a professional software engineer.


**References:**
1. Ian Sommerville & Addison Wesley, Software Engineering, 9th Edition, Published by Pearson in Newyork, Year 2011.
2. AWS Amazon, https://aws.amazon.com/, 6th June 2024
3. Vikram Bali et all, Software Engineering, Second edition, Published by S.K. Kataria & Sons, in Ansari road, Darya Ganj, New Dehli in 2010
4. IEEE Computer Society, https://www.computer.org/education/code-of-ethics, 7th June 2024
5. The Dev Post, https://thedevpost.com/blog/challenges-in-software-project-management/, 7th June 2024

